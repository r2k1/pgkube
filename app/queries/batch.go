// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: batch.go

package queries

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const upsertPodUsedCPU = `-- name: UpsertPodUsedCPU :batchexec
insert into pod_usage_hourly (timestamp, namespace, name, node_name, cpu_cores_max, cpu_cores_min, cpu_cores_total,
                              cpu_cores_total_readings)
values ($1, $2, $3, $4, $5, $5, $5, 1)
on conflict (timestamp, namespace, name, node_name)
    do update set cpu_cores_total_readings = pod_usage_hourly.cpu_cores_total_readings + 1,
                  cpu_cores_max            = case
                                                 when pod_usage_hourly.cpu_cores_max > $5
                                                     then pod_usage_hourly.cpu_cores_max
                                                 else $5 end,
                  cpu_cores_min            = case
                                                 when pod_usage_hourly.cpu_cores_min < $5 and
                                                      pod_usage_hourly.cpu_cores_min != 0
                                                     then pod_usage_hourly.cpu_cores_min
                                                 else $5 end,
                  cpu_cores_total          = pod_usage_hourly.cpu_cores_total + $5
`

type UpsertPodUsedCPUBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpsertPodUsedCPUParams struct {
	Timestamp   pgtype.Timestamptz
	Namespace   string
	Name        string
	NodeName    string
	CpuCoresMax float64
}

func (q *Queries) UpsertPodUsedCPU(ctx context.Context, arg []UpsertPodUsedCPUParams) *UpsertPodUsedCPUBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Timestamp,
			a.Namespace,
			a.Name,
			a.NodeName,
			a.CpuCoresMax,
		}
		batch.Queue(upsertPodUsedCPU, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpsertPodUsedCPUBatchResults{br, len(arg), false}
}

func (b *UpsertPodUsedCPUBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *UpsertPodUsedCPUBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const upsertPodUsedMemory = `-- name: UpsertPodUsedMemory :batchexec
insert into pod_usage_hourly (timestamp, namespace, name, node_name, memory_bytes_max, memory_bytes_min,
                              memory_bytes_total,
                              memory_bytes_total_readings)
values ($1, $2, $3, $4, $5, $5, $5, 1)
on conflict (timestamp, namespace, name, node_name)
    do update set memory_bytes_total_readings = pod_usage_hourly.memory_bytes_total_readings + 1,
                  memory_bytes_max            = case
                                                    when pod_usage_hourly.memory_bytes_max > $5
                                                        then pod_usage_hourly.memory_bytes_max
                                                    else $5 end,
                  memory_bytes_min            = case
                                                    when pod_usage_hourly.memory_bytes_min < $5 and
                                                         pod_usage_hourly.memory_bytes_min != 0
                                                        then pod_usage_hourly.memory_bytes_min
                                                    else $5 end,
                  memory_bytes_total          = pod_usage_hourly.memory_bytes_total + $5
`

type UpsertPodUsedMemoryBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpsertPodUsedMemoryParams struct {
	Timestamp      pgtype.Timestamptz
	Namespace      string
	Name           string
	NodeName       string
	MemoryBytesMax float64
}

func (q *Queries) UpsertPodUsedMemory(ctx context.Context, arg []UpsertPodUsedMemoryParams) *UpsertPodUsedMemoryBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Timestamp,
			a.Namespace,
			a.Name,
			a.NodeName,
			a.MemoryBytesMax,
		}
		batch.Queue(upsertPodUsedMemory, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpsertPodUsedMemoryBatchResults{br, len(arg), false}
}

func (b *UpsertPodUsedMemoryBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *UpsertPodUsedMemoryBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
