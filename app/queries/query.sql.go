// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listPodUsageHourly = `-- name: ListPodUsageHourly :many
select pod_uid, timestamp, namespace, name, node_name, memory_bytes_max, memory_bytes_min, memory_bytes_total, memory_bytes_total_readings, memory_bytes_avg, cpu_cores_max, cpu_cores_min, cpu_cores_total, cpu_cores_total_readings, cpu_cores_avg from pod_usage_hourly order by timestamp desc limit 100
`

func (q *Queries) ListPodUsageHourly(ctx context.Context) ([]PodUsageHourly, error) {
	rows, err := q.db.Query(ctx, listPodUsageHourly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PodUsageHourly
	for rows.Next() {
		var i PodUsageHourly
		if err := rows.Scan(
			&i.PodUid,
			&i.Timestamp,
			&i.Namespace,
			&i.Name,
			&i.NodeName,
			&i.MemoryBytesMax,
			&i.MemoryBytesMin,
			&i.MemoryBytesTotal,
			&i.MemoryBytesTotalReadings,
			&i.MemoryBytesAvg,
			&i.CpuCoresMax,
			&i.CpuCoresMin,
			&i.CpuCoresTotal,
			&i.CpuCoresTotalReadings,
			&i.CpuCoresAvg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stopOtherPods = `-- name: StopOtherPods :exec
update pod
set deleted_at = $1
where deleted_at is null
  and pod_uid != all ($2::uuid[])
`

type StopOtherPodsParams struct {
	DeletedAt      pgtype.Timestamptz
	RunningPodUids []pgtype.UUID
}

func (q *Queries) StopOtherPods(ctx context.Context, arg StopOtherPodsParams) error {
	_, err := q.db.Exec(ctx, stopOtherPods, arg.DeletedAt, arg.RunningPodUids)
	return err
}

const upsertJob = `-- name: UpsertJob :exec
insert into job(job_uid, name, namespace, labels, annotations, controller_uid, controller_kind, controller_name, created_at,
                deleted_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
on conflict (job_uid)
    do update set name        = $2,
                  namespace   = $3,
                  labels      = $4,
                  annotations = $5,
                  controller_uid   = $6,
                  controller_kind  = $7,
                  controller_name  = $8,
                  created_at  = $9,
                  deleted_at  = $10
`

type UpsertJobParams struct {
	JobUid         pgtype.UUID
	Name           string
	Namespace      string
	Labels         []byte
	Annotations    []byte
	ControllerUid  pgtype.UUID
	ControllerKind string
	ControllerName string
	CreatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
}

func (q *Queries) UpsertJob(ctx context.Context, arg UpsertJobParams) error {
	_, err := q.db.Exec(ctx, upsertJob,
		arg.JobUid,
		arg.Name,
		arg.Namespace,
		arg.Labels,
		arg.Annotations,
		arg.ControllerUid,
		arg.ControllerKind,
		arg.ControllerName,
		arg.CreatedAt,
		arg.DeletedAt,
	)
	return err
}

const upsertPod = `-- name: UpsertPod :exec
insert into pod (pod_uid, name, namespace, node_name, labels, annotations, controller_uid, controller_kind,
                 controller_name, request_cpu_cores, request_memory_bytes, created_at, deleted_at, started_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
on conflict (pod_uid)
    do update set name                 = $2,
                  namespace            = $3,
                  node_name            = $4,
                  labels               = $5,
                  annotations          = $6,
                  controller_uid            = $7,
                  controller_kind           = $8,
                  controller_name           = $9,
                  request_cpu_cores    = $10,
                  request_memory_bytes = $11,
                  created_at           = $12,
                  deleted_at           = $13,
                  started_at           = $14
`

type UpsertPodParams struct {
	PodUid             pgtype.UUID
	Name               string
	Namespace          string
	NodeName           string
	Labels             []byte
	Annotations        []byte
	ControllerUid      pgtype.UUID
	ControllerKind     string
	ControllerName     string
	RequestCpuCores    float64
	RequestMemoryBytes float64
	CreatedAt          pgtype.Timestamptz
	DeletedAt          pgtype.Timestamptz
	StartedAt          pgtype.Timestamptz
}

func (q *Queries) UpsertPod(ctx context.Context, arg UpsertPodParams) error {
	_, err := q.db.Exec(ctx, upsertPod,
		arg.PodUid,
		arg.Name,
		arg.Namespace,
		arg.NodeName,
		arg.Labels,
		arg.Annotations,
		arg.ControllerUid,
		arg.ControllerKind,
		arg.ControllerName,
		arg.RequestCpuCores,
		arg.RequestMemoryBytes,
		arg.CreatedAt,
		arg.DeletedAt,
		arg.StartedAt,
	)
	return err
}

const upsertReplicaSet = `-- name: UpsertReplicaSet :exec
insert into replica_set (replica_set_uid, name, namespace, labels, annotations, controller_uid, controller_kind,
                         controller_name, created_at, deleted_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
on conflict (replica_set_uid)
    do update set name        = $2,
                  namespace   = $3,
                  labels      = $4,
                  annotations = $5,
                  controller_uid   = $6,
                  controller_kind  = $7,
                  controller_name  = $8,
                  created_at  = $9,
                  deleted_at  = $10
`

type UpsertReplicaSetParams struct {
	ReplicaSetUid  pgtype.UUID
	Name           string
	Namespace      string
	Labels         []byte
	Annotations    []byte
	ControllerUid  pgtype.UUID
	ControllerKind string
	ControllerName string
	CreatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
}

func (q *Queries) UpsertReplicaSet(ctx context.Context, arg UpsertReplicaSetParams) error {
	_, err := q.db.Exec(ctx, upsertReplicaSet,
		arg.ReplicaSetUid,
		arg.Name,
		arg.Namespace,
		arg.Labels,
		arg.Annotations,
		arg.ControllerUid,
		arg.ControllerKind,
		arg.ControllerName,
		arg.CreatedAt,
		arg.DeletedAt,
	)
	return err
}
